<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns="http://www.springframework.org/schema/security"

             xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd       
">
    <!-- security -->
    <http>
        <form-login />
        <http-basic />
        <logout />
        <intercept-url pattern="/admin/**" access="ROLE_ADMIN" />
        <intercept-url pattern="/add/**" access="ROLE_USER"/>
        <!-- Spring Security will see that it requires
        the https channel and automatically redirect the request to go over HTTPS
        -->
        <intercept-url pattern="/login" requires-channel="https"/>
        <intercept-url pattern="/form" requires-channel="http"/>
        <remember-me
            key="spitterKey"
            token-validity-seconds="2419200" />        
    </http>
    
    <!-- or this way -->
    <!--<http auto-config="true">
        <intercept-url pattern="/admin" access="ROLE_ADMIN" />
    </http>    
    -->
    
    <!-- JSP tags -->
    <!-- 
        <authhorize url="">
        <authentication property="principal.username" scope="request">
        <%@taglib prefix="" uri="org.springframework.org/security/tags"%>
    -->
    <!-- User Repository -->
    <user-service id="userService">
        <user name="admin" password="admin" authorities="ROLE_SPITTER,ROLE_ADMIN"/>
        <user name="director" password="director" authorities="ROLE_SPITTER"/>
        <user name="employee" password="employee" authorities="ROLE_ADMIN"/>
    </user-service>
    
    <!-- Authentication ProviderManager -->
    <authentication-manager>
        <authentication-provider user-service-ref="userService"/>
    </authentication-manager>
    
    <!-- DataSource User Repository -->
    <!-- The <jdbc-user-service> element uses a JDBC data source—wired in through
        its data-source-ref attribute—to query a database for user details. 
        Without any further configuration, the user service queries for user 
        information using the following SQL:
            select username,password,enabled
            from users
            where username=?    
    -->
    <jdbc-user-service id="dbUserService" data-source-ref="dataSource" />
    
    <!-- or this way -->
    <!-- 
    <jdbc-user-service id="dbUserService" data-source-ref="dataSource"
        users-by-username-query="select username,password,true from users where username=?"
        authorities-by-username-query="select username,'ROLE_SPITTER' from user where username=?"
        group-authorities-by-username-query="select username, 'ADMINISTRATION' from users where username=?"
    />
    -->
    
    <!-- Hierarchical LDAP User Repository -->
    <authentication-manager alias="authenticationManager">
        <ldap-authentication-provider user-search-filter="(uid={0})"
                                      group-search-filter="member={0}">
            <!-- LDAP provider will compare passwords on the server side 
            so the actual password is keep in secret. But when you attempt 
            to transmit a entered password over the network it will be available 
            for the hacker/cdn whatsoever. To prevent this you nedd to pin
            encryption strategy / hash method to be evaluated against the 
            entered password on the client side. Choises:
            {sha}{ssha}{md4}{md5}{plaintext}{sha}{sha-256}
            -->
            <password-compare password-attribute="passcode" hash="md5"/>
        </ldap-authentication-provider>        
    </authentication-manager>
    
    <ldap-user-service id="userService"
                       user-search-base="ou=people"
                       user-search-filter="(uid={0})"
                       group-search-base="ou=groups"
                       group-search-filter="member={0}"
    />
        
    <!-- By default, Spring Security’s LDAP authentication assumes that the LDAP server is
    listening on port 33389 on localhost. But if your LDAP server is on another machine,
    then you can use the <ldap-server> element to configure the location:
    -->
    <ldap-server url="ldap://habuma.com:389/dc=habuma,dc=com"/>
    
    <!-- 
    If you don’t happen to have an LDAP server laying around waiting to be authenticated
    against, then the <ldap-server> can also be used to configure an embedded LDAP
    server. Just leave off the url parameter. For example:
        <ldap-server root="dc=habuma,dc=com" ldif="classpath:users.ldif"/>
    -->
    
    <!--Users LDIF -->
    <!--dn: ou=groups,dc=habuma,dc=com
    objectclass:top
    objectclass:organizationalUnit
    ou: groups
    dn: ou=people,dc=habuma,dc=com
    objectclass:top
    objectclass:organizationalUnit
    ou: people
    dn: uid=habuma,ou=people,dc=habuma,dc=com
    objectclass:top
    objectclass:person
    objectclass:organizationalPerson
    objectclass:inetOrgPerson
    cn: CraigWalls
    sn: Walls
    uid: habuma
    userPassword:password
    dn: uid=jsmith,ou=people,dc=habuma,dc=com
    objectclass:top
    objectclass:person
    objectclass:organizationalPerson
    objectclass:inetOrgPerson
    4 See http://tools.ietf.org/html/rfc2849 for more details on the LDIF specification.
    Listing9.6A sample LDIF file used to load user details into LDAP
    Licensed to Christian Cederquist <chrisman@kaus.dk>
    Authentic 245 ating users
    cn: JohnSmith
    sn: Smith
    uid: jsmith
    userPassword:password
    dn: cn=spitter,ou=groups,dc=habuma,dc=com
    objectclass:top
    objectclass:groupOfNames
    cn: spitter
    member: uid=habuma,ou=people,dc=habuma,dc=com-->
    
    <!-- Method invocation Securoty -->
    <!-- 
        @Secured - Spring
        @RolesAllowed - JSR-250
        @PreFilter @PostFilter @PreAuthorize @PostAuthorize
        explicit pointcuts
        
        examples:
        1. @Secured({'ROLE_USER', 'ROLE_ADMIN'})
           public String securedMethod(UserModel model) throws AuthenticationException, AccessDeniedException
        2. @RolesAllowed('ROLE_ADMIN')   
           public String securedMethod(UserMOdel model) throw AuthenticationException, AcessDeniedException
              + @DenyAll @PermitAll 
        3. @PreAuthorise('hasRole('ROLE_ADMIN') and #spitter.spittle.length() < 140 or hasRole('ROLE_PREMIUM')")
           @PostAuthorize('hasRole('ROLE_ADMIN') and returnObject.username == principal.username')
           @PostFilter('filterObject.username == principal.username')  :  filters return List<Spittle>
    -->
    <global-method-security secured-annotations="enabled" pre-post-annotations="enabled">
        <expression-handler ref="expressionHandler" />
        <protect-pointcut expression="execution(@sp.Sensible * *.*(String)) and args(id,value)" access="ROLE_SPITTER, ROLE_ADMIN" />
    </global-method-security>
    
    <beans:bean id="expressionHandler" 
                class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler">
        <beans:property name="permissionEvaluator">
            <beans:bean class="com.habuma.spitter.security.SpittlePermissionEvaluator" />
        </beans:property>
    </beans:bean>
    
    

</beans:beans>
